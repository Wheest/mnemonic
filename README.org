#+TITLE: Mnemonic
#+STARTUP: content
** Motivation
For privacy preserving technology to see widespread adoption, it must be accessible.

One of the key problems is how to handle identity.  In a centralised system, the authority can be in charge of what name (e.g. mobile phone number, web domain) is associated with what identity (person, server).  However, in decentralised ones, this is not as easy.

Messaging systems such as [[https://ricochet.im/][Ricochet]] and [[https://cwtch.im/][Cwtch]] purport to be privacy preserving protocols.  However, identifiers are not easy for humans to read or remember.

This document looks at some ways that addresses could be made more readable, by converting base64 encoded strings into a base-2048 encoded string.  Taking a cue from [[https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki][BIP-0039]], digits in base-2048b are represented by words.

For example, the base-2048 representation of the decimal digit ~1~ is ~ability~.  Below is a table with further examples:

| Base-10     | Base-2048             |
|-------------+-----------------------|
| ~1~         | ~ability~             |
| ~1729~      | ~subway~              |
| ~2047~      | ~zoo~                 |
| ~2048~      | ~ability abandon~     |
| ~100000000~ | ~actual stuff cactus~ |

The full list of words used in this example can be seen [[english.txt]].  It is worth noting that [[https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki][BIP-0039]] used the words as a source of human readable entropy for generating private keys (the word list dubbed a "seed phrase"), and should never be shared.  One can use an arbitrary word list, as long as one knows what encoding one is using.  Thus there are [[https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md][word-lists for multiple languages]]. 

However, in our context, since identifiers are supposed to be shared, having different parties using different word list creates a potential for error.  Settling on using one list of English words might be viewed as [[https://en.wiktionary.org/wiki/Anglocentrism][anglocentrism]].  This issue is left open for discussion.
** Conversion of Ricochet addresses
Let us take an example of a Ricochet addresses in our base2048 format.  An example from the [[https://ricochet.im/][Ricochet website]] is ~ricochet:rs7ce36jsj24ogfw~.  Let us assume that it is encoded in base-36 (decimal digits + lower-case ASCII letters), and take the 16 characters after the colon.

For simplicity (see: fast prototype), we have two functions, ~base_n_to_dec()~ and ~dec_to_base_n()~.  

- ~base_n_to_dec()~ takes a baseN encoded number, baseN itself, and a dictionary that maps baseN digits to decimal numbers.  It returns the baseN encoded number and returns it encoded in base 10.
- ~dec_to_base_n()~ is the inverse of this operation

This is a proof of concept, so try to ignore implementation peculiarities and inefficiencies.

#+BEGIN_SRC python :results output :session convert
def base_n_to_dec(base_n_number, base_n, baseN_to_dec_dict):
    ret = 0
    for i, c in enumerate(base_n_number[::-1]):
        ret += (base_n ** i) * baseN_to_dec_dict[c]
    return ret

def dec_to_base_n(number, base, dec_to_baseN_dict):
    if number == 0:
        return [0]
    digits = []
    while number:
        digits.append(dec_to_baseN_dict[int(number % base)])
        number //= base
    return digits[::-1]
#+END_SRC

#+RESULTS:

Now let's get our mapping from base36 to decimal:

#+BEGIN_SRC python :results output :session convert
import string
base36 = string.digits + string.ascii_lowercase 
base36_to_dec_dict = dict((c, i) for i, c in enumerate(base36))
dec_to_base36_dict = dict((i, c) for i, c in enumerate(base36))

base36_address = "rs7ce36jsj24ogfw"
base36_address = "vww6ybal4bd7szmgncyruucpgfkqahzddi37ktceo3ah7ngmcopnpyyd" # (onionv3 address)

base10_address = base_n_to_dec(base36_address, 36, base36_to_dec_dict)

# assert that the operation is reversible (it is)
reverse_verify = dec_to_base_n(base10_address, 36, dec_to_base36_dict)
reverse_verify = ''.join(reverse_verify)
assert(base36_address == reverse_verify)
#+END_SRC

#+RESULTS:

With that done, now we can convert to our base2048 encoding.  We do this in the same way we created our base36 encoding, but using words from our file ~english.txt~.

#+BEGIN_SRC python :results output :session convert
with open("english.txt") as f:
    english_words_list = f.read().splitlines() 

base2048 = english_words_list

base2048_to_dec_dict = dict((c, i) for i, c in enumerate(base2048))
dec_to_base2048_dict = dict((i, c) for i, c in enumerate(base2048))
#+END_SRC

#+RESULTS:

Finally let's convert our Ricochet address to base2048

#+BEGIN_SRC python :results output :session convert
base2048_address = dec_to_base_n(base10_address, 2048, dec_to_base2048_dict)
print(base10_address)
print(base2048_address)
print(len(base2048_address))
# returns ['agree', 'pipe', 'dry', 'song', 'piece', 'bind', 'better', 'pole']
# len = 8

# assert that the operation is reversible (it is)
reverse_verify = base_n_to_dec(base2048_address, 2048, base2048_to_dec_dict)
reverse_verify = dec_to_base_n(reverse_verify, 36, dec_to_base36_dict)
reverse_verify = ''.join(reverse_verify)

assert(base36_address == reverse_verify)
#+END_SRC

#+RESULTS:
: 1260709712996318955898685272226231504720057513191589823776137029904096611564534973626421
: ['access', 'cat', 'pig', 'erase', 'suggest', 'tumble', 'enemy', 'bonus', 'client', 'dentist', 'offer', 'kitten', 'topple', 'tired', 'lake', 'push', 'ocean', 'version', 'solid', 'virus', 'toddler', 'soft', 'kite', 'eternal', 'exit', 'faint', 'allow']
: 27

Okay then, what do we have here now?  An 8 word long phrase, replacing a 16 character long string.  Is this an improvement from a usability standpoint?

Things get worse when you use an onion v3 address.  A 56 character long base36 string, which we believe is the typical length of an onion v3 address, is represented by 27 words.  This does not seem workable at all.
* Longer word list
What if we used a longer word list? This quick and dirty approach [[https://gist.github.com/h3xx/1976236][copies a file]] with around 100k words (scraped from an online dictionary).  If this approach were adopted, a cleaned version would be used.
#+BEGIN_SRC python :results output :session convert
with open("wiki-100k.txt") as f:
    english_words_100k_list = f.read().splitlines() 

base100K = english_words_100k_list
dec_to_base100K_dict = dict((i, c) for i, c in enumerate(base100K))
base100K_to_dec_dict = dict((c, i) for i, c in enumerate(base100K))

base100k_address = dec_to_base_n(base10_address, len(base100K), dec_to_base100K_dict)
# returns ['meanwhile', 'lining', 'vigor', 'Durham', 'legen']
#+END_SRC

#+RESULTS:

For the Ricochet address format, this returns a much more workable 5 word long string.  The Onionv3 address is around 18 words long.  However, in this approach the word list is around 800KB in size.
* Using Base56
An alternative to using base36 is base56, a format popularised by Bitcoin addresses.  In this format, easily confused characters such as capital o (O) and numeric zero (0) are removed from the symbol set.
#+BEGIN_SRC python :results output :session convert
base56 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
dec_to_base56_dict = dict((i, c) for i, c in enumerate(base56))
base56_to_dec_dict = dict((c, i) for i, c in enumerate(base56))

base56_address = dec_to_base_n(base10_address, 56, dec_to_base56_dict)
print(''.join(base56_address))
print(len(base56_address))
#+END_SRC

#+RESULTS:
: UVEhFhp55ZtkrSJuYaqNArfemiQ2Q8xrTAbVYe5VC86qtvq1eW
: 50

In the encoding, our Ricochet format address is now 15 characters, down from 16.  Our OnionV3 address is 50 characters, down from 56.  It is clear that the length reduction is not worth the user-side complexity of including capital letters.
* Conclusion 
The problem of having human-usable unique identifiers in a decentralised system is an open question, and this work attempts to explore some of the possibilities.  Using some sort of decentralised DNS system such as NameCoin or Blockstack is also a possibility, but creates a bit-trail that some users might be unwilling to make.
* Addendum
After sharing this post with the cwtch community, I was directed to a [[https://github.com/ricochet-im/ricochet/issues/128#issuecomment-107001948][previous exploration of the idea]] from SJL.  Some of the conclusions were similar, however with an interesting additional component.

This involved using a different word list for each word in a mnemonic, i.e. the first is chosen from an adjective list, the next to a noun, then verb, etc.  This would form something like a sentence, as can be seen in SJL's examples:

#+BEGIN_SRC sh
the quick fire open the usual dais 
the fluid ball line the true bag 
the close seal pay the black coil 
the gay eft burn the angry fart 
the warm bank call the live jest 
#+END_SRC

Again, since words lists might not be feasible for representing long addresses, the point is moot.  However, with further research on real-world usability, it might be an interesting system to implement in situations where fewer bits are needed.
